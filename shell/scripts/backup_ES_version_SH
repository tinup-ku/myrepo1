#!/bin/bash
###############################################################################
# Prior to Splunk Enteprise Security Upgrade to higher version, this script
# performs the following tasks.
# 1. Stop splunkd
# 2. In ${SPLUNK_SNAPSHOT}, clean up all .bundle except the latest. The backup
#    resides in 
#    ${SPLUNK_VAR_RUN}/snapshot-ES_version_${current_ES_version}.tar.gz
# 3. Backup ${SPLUNK_ETC}
#    Output: ${SPLUNK_ETC}/etc-splunk-ES_version_${version}.tar.gz
# NOTE:
# In case backout's needed, run, backout_ES_version_SH on each ES Search Head.
###############################################################################
# Written by user1 | T O S Platform Splunk
# Based on user2 Llamado's inputs thru many trial runs.
SPLUNK_HOME=/opt/splunk
SPLUNK_ETC=${SPLUNK_HOME}/etc
SPLUNK_SNAPSHOT=${SPLUNK_HOME}/var/run/splunk/snapshot
SPLUNK_VAR_RUN=${SPLUNK_HOME}/var/run/splunk
date_=`date '+%Y%m%d'`

[[ ! $1 ]] && {
  echo "Need to enter option."
  echo "For example,"
  echo "$0 641"
  exit
}

stop_splunk_process ()
{
# Is it systemd or systemV init?
  if [[ -f /etc/systemd/system/Splunkd.service ]]
  then
     systemctl stop Splunkd
  else
     if [[ -f /etc/init.d/splunk ]]
     then
        service splunk stop
     fi
  fi
  # Verify
  pgrep -u ${pre_uid} splunkd >/dev/null 2>&1
  [[ "$?" = "0" ]] && pgrep -u ${pre_uid} splunkd | xargs kill -9
  pgrep -u ${pre_uid} mongod >/dev/null 2>&1
  [[ "$?" = "0" ]] && pgrep -u ${pre_uid} mongod | xargs kill -9
}

check_splunk_process ()
{
    ps aux|grep [s]plunk >/dev/null
    status=$?
    [[ "$status" != "0" ]] && {
      echo "Splunk is still UP. Upgrade to Splunk version ${ver} Aborted."
      ps aux|grep [s]plunk
      exit 2
    }
}

##########
# M A I N
##########
{
  # Stop splunk
  stop_splunk_process

  splunk_status=`show_splunk|awk '/SPLUNK/{print $NF}'`
  echo splunk_status=$splunk_status
  [[ "${splunk_status}" = "UP" ]] && {
    echo "Splunk is still running. Try to stop Splunk again"
    stop_splunk_process
  }

  cd ${SPLUNK_SNAPSHOT} && {
     # Get total .bundle count 
     bundle_count=$(ls -Art *.bundle 2>/dev/null|wc -l)
     if [[ ${bundle_count} -gt 1 ]]
     then
       echo "Below are list of current .bundle:"
       ls -ltr
       # Identify latest bundle
       echo
       latest=`ls -Art  | tail -n 1`
       echo "Latest bundle:"
       ls -ltr ${latest}
       echo "Below are list of .bundle to remove:"
       find . -type f ! -name  ${latest} ! -newer ${latest} -exec ls -ltr {} +
       echo "Removing .bundle above"
       find . -type f ! -name  ${latest} ! -newer ${latest} -exec rm -f {} +
     else
       echo "There's only 1 .bundle. Proceed with backing up ${SPLUNK_SNAPSHOT}"
     fi
  }
  echo "1. Backing up ${SPLUNK_SNAPSHOT}: snapshot-ES_version_${1}.tar.gz"
  echo "   ${SPLUNK_VAR_RUN}/snapshot-ES_version_${1}.tar.gz"
  cd ${SPLUNK_HOME}/var/run/splunk && {
     # Check if snapshot is empty
     if [[ -z "$(ls -A snapshot)" ]]
     then
         echo "${SPLUNK_SNAPSHOT} is empty. Skipping backup..."
     else
         tar czpf snapshot-ES_version_${1}.tar.gz snapshot/
         ls -l snapshot-ES_version_${1}.tar.gz
     fi
  }
  echo
  echo "2. Backing up ${SPLUNK_ETC}: etc-splunk-ES_version_${1}.tar.gz"
  echo "   ${SPLUNK_HOME}/etc-splunk-ES_version_${1}.tar.gz"
  cd ${SPLUNK_HOME} && {
     echo
     echo "Backing up ${SPLUNK_ETC}"
     tar czpf etc-splunk-ES_version_${1}.tar.gz etc/
     echo "Verifying:"
     [[ -f etc-splunk-ES_version_${1}.tar.gz ]] && \
        ls -l etc-splunk-ES_version_${1}.tar.gz
  }
} | tee /root/`basename $0`.${date_}.OUT
echo "OUTPUT: /root/`basename $0`.${date_}.OUT"
