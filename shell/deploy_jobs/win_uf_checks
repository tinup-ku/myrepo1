#!/bin/bash
##############################################################
##############################################################
## This script checks the firwall ports from windows hosts to Indexers(port 9990) and
## also to deployment servers(port 8089) using  salt
## At present port is checked for prod indexer cluster CD1_B
## Bitbucket link:
##    https://bitbucketdomain1/projects/AD00203364/repos/tos_splunk_core/browse/salt/states/uf_fw_checks.sls
##############################################################
## Written by: user3@mycorp.com
## Contributors: user2@mycorp.com, user1@mycorp.com
##############################################################

    this_script=`basename $0`
    logfile="/var/tmp/${this_script}.log"
    echo > $logfile

    set_mode () {
        # salt apply mode for testing : "apply_state_tst" or "apply_state" to enforce
        apply_="apply_state"
        #apply_="apply_state_tst"

        #mode="${@: -1}"
        #if [[ "$mode"="test" ]]
        #  then
        #  apply_="apply_state_tst"
        #elif [[ "$mode"="enforce" ]]
        #  then
        #  apply_e="apply_state"
        #else
        #  echo "Apply mode is invalid"
        #  exit 1
        #fi

    }

    envs_parse () {
        case ${env_} in
           dev )
                auth_key="OPzKBTEFz9fwoZGa1hSKhnBJC3wQhTQFxlgu8pRNqPOnR9fLPhaxeSopyjtuQ2qvvmDGqN668tPsk9cuNFJ1RWdRiUaphg2crLKquczvBEH4fOd73sLJOGx4xIPqYQV2"
                auth_token="uxiAghf9eCfnsCZnf9xwlBZ5iBHe6WdBtvcKNrT149owLoU1xrxS2wYk7FzeBMP5h2P4uJ5ySu5DSZFqqcjtJhNRWm5y9VEqXuusdA0555JX5oovBHZlYMcV9iuie8Jc"
                state_file="app_iaas_serviceassuranceservices_dev.AD00006311_splunk_core.salt.states.uf_fw_checks"
                ;;
           qa )
                auth_key="exenXiAaz283lPEtuKXTBVmdL7yqoG0CefZbxAm7DvaYkOrPzpIak5n5dVwBCxdQNd2kNpsqUCperR30gMbASyG5udH7KUYy81SVqlmkXLzpCDpTpBtiaanEn4M8ZKG7"
                auth_token="Mz3cUpxSb6hOKHH9ibsslP7JUTRTEx0q74D1uaTFhau1SbbamDDItKrnEjgiQhJXlnZPxSvP3ZQVb26yFJg8uIv81MrS4bQqyQg6JLVMLMIWOPuuyLC3u8bwVDoZOfpm"
                state_file="app_iaas_serviceassuranceservices_dev.AD00006311_tos_tmp.salt.states.uf_fw_checks"
                ;;
           prod )
                auth_key="BA8bQdSoBebS5QRCmz2oVDmmTTVaGZ912P7bhp8Nv6i26xTYGLhv6bqqRk9jGMXnv7p01dOvykuWt9zH2Q1S4ijuTBOWCiLuD55WKxNNAn2CAsVPkawv1OtcGjtVDpxZ"
                auth_token="RDJhqOJnK880I3B4ry916g12lQC8aRh2u1jUP3izbqAUubZVK8XQoZSKPvTZna1SblM0p5AAwav0muW6CTX1SPMHlFGIPIA14n2ttC4ZMzZ93VfGOcHH2too857YOI0S"
                state_file="app_iaas_serviceassuranceservices_prod.AD00006311_splunk_core.salt.states.uf_fw_checks"
                ;;
           *)
               echo "Invalid environment: ${env_}" | tee -a $logfile
               #echo -e "${Red}  ERROR: Invalid environment: pls enter environment for  qa, dev or prod: ${White}"
               echo "Usage: $this_script <dev/prod>  <server>"
               exit 1
               ;;
        esac
        }

    ## check JID status
    check_jid () {
        job_id=$1
        curl -s --location --request GET \
        https://cmaapidomain1/salt/job_status/$job_id \
        -H "X-Auth-Key: ${auth_key}" \
        -H "X-Auth-Token: ${auth_token}"
        }


   check_jid_output () {
        this_id=$1

        curl -s --location --request GET \
        https://cmaapidomain1/salt/jobs/$this_id \
        -H "X-Auth-Key: ${auth_key}" \
        -H "X-Auth-Token: ${auth_token}"
        }


    ## Apply states in test mode
    apply_state_tst () {
    myhost=$1
    myout=$(curl -s --location --request POST 'https://cmaapidomain1/salt/apply_state' \
        --header "X-Auth-Key: ${auth_key}" \
        --header "X-Auth-Token: ${auth_token}" \
        --header 'Content-Type: application/json' \
        --data '[{
        "target": "'"${myhost}"'",
        "tgt_type": "list",
        "file": "'"${state_file}"'",
        "test": "true"
        }]' )
    echo $myout
    }

    ## Apply states & enforce changes
    apply_state () {
    myhost=$1
    myout=$(curl -s --location --request POST 'https://cmaapidomain1/salt/apply_state' \
        --header "X-Auth-Key: ${auth_key}" \
        --header "X-Auth-Token: ${auth_token}" \
        --header 'Content-Type: application/json' \
        --data '[{
        "target": "'"${myhost}"'",
        "tgt_type": "list",
        "file": "'"${state_file}"'"
        }]' )
    echo $myout
    }

    ## Apply state
    echo ""
    #envs_parse
    #user_parse
    env_="$1"
    env1="$1"
    envs_parse
    user_="root"
    uf_host="$2"
    if [[ -z $uf_host ]]
      then
      echo "Usage: $this_script <dev/prod>  <server>"
      exit 1
    fi

    set_mode

    for thishost in ${uf_host[@]}; do
    echo "=============================="

    echo "`date`: Checking: $thishost   environment: $env_   user: $user_ " >> $logfile
    if [[ $apply_ = "apply_state_tst" ]]
    then
        echo "Applying in test mode.."
        echo "`date`: Applying in test mode.." >> $logfile
    fi

    ### test
    #done  ; exit 0

    out1=$(${apply_} $thishost)
    #echo $out1   #  apply_="test"
    myjid=$(echo $out1 | awk '{print $3}' | sed s/,//g | sed s/\"//g)
    #echo $myjid
    jid_out=$(check_jid $myjid)
    #echo $jid_out
    echo $jid_out | grep -qi running
    if [[ "$?" = 0 ]]; then
        echo "Start: `date`"
        echo "Checking on $thishost ..."
        n=0
        result="running"
        while [ $result = "running"  ]
          do
              (( n++ ))
              echo "   Waiting 10 secs.."
              echo "`date`: Still running JID:$myjid  ..will check again($n) a sleep" >> $logfile
              sleep 10
              jid_out="$(check_jid $myjid)"
              echo $jid_out | grep -qi running
              if [[ "$?" = 0 ]]; then
              result="running"
                  if [[ $n -gt 200 ]]
                  then
                  echo -e "${Red} Running for long time.. Exiting with error.. ${White}"
                  echo "`date`:Running for more than 30 minutes.. Exiting... $jid_out" >> $logfile
                  #echo "${this_script}:Running to long..$jid_out" | mailx -s "${this_script}:Running too long..." ${mail_to}
                  exit 1
                  fi
              else
                  echo "`date`:Status changed for: JID: $myjid" >> $logfile
                  #echo "" ; echo "`date`: $jid_out"
                  echo "`date`: $jid_out" >> $logfile
                  result="not_running"
              fi
          done
    else
        echo "Status changed for: JID: $myjid" >>  $logfile
        #echo "" ; echo "`date`: $jid_out"
        echo "`date`: $jid_out" >> $logfile
    fi

    out2=$(grep  state $logfile | grep $thishost )
    if [[ "$?" = 0 ]]; then
        echo $out2 | grep -qi complete
        if [[ "$?" = 0 ]]; then
           echo "Finish: `date`"
           echo "`date`: $thishost complete" >> $logfile
         else
           echo "" ; echo -e "${Red} $thishost NOT done...Exiting ${White}"
           echo "`date`: $thishost not done...Exiting" >> $logfile
           #echo "${this_script}: Failed to run on $thishost" | mailx -s "${this_script}: Failed to run on $thishost" ${mail_to}
           exit 1
        fi
    else
       echo "" ; echo -e "${Red} ERROR: $thishost didn't run the state...Exiting  ${White}"
       echo "`date`: $thishost didn't run the state...Exiting"  | tee -a $logfile
       #echo "${this_script}: Failed to run on $thishost" | mailx -s "${this_script}: Failed to run on $thishost" ${mail_to}
       exit 1
    fi


    jid_output=$(check_jid_output $myjid )
    #echo $jid_output | python -m json.tool
    echo "Salt Apply Output:"  >>  $logfile
    echo $jid_output >>  $logfile
    #echo $jid_output | /usr/local/bin/jq >>  $logfile
    echo $jid_output | grep -q "result"
    if [[ "$?" != 0 ]]; then
      echo "`date`: Error while applying salt state: " | tee -a $logfile
      echo "$jid_output" | grep -q "error" >> $logfile
      {
        echo "   JID:${myjid}" ; echo "$jid_output"
      } #| mailx -s "${this_script}: env(${env_}): Error to apply state on $thishost" ${mail_to}
      exit 1
    else
       echo "`date`: Salt Apply Result:"  >>  $logfile
       echo $jid_output | python -m json.tool | egrep "__id__|result" >> $logfile
       echo "$jid_output" |  python -m json.tool | grep -i tcp | sed -e 's/True/True\n/g' -e 's/False/False\n/' -e 's/failed/failed\n/' -e 's/\\r\\n\|"//g' -e 's/stdout://g'  | awk '{$1=$1};1'
    fi

   done

